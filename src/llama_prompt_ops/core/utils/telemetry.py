# Copyright (c) Meta Platforms, Inc. and affiliates.
# All rights reserved.
#
# This source code is licensed under the terms described in the LICENSE file in
# the root directory of this source tree.
"""
Telemetry module for tracking and displaying optimization process information.

This module provides classes and utilities for collecting and displaying
key information about the optimization process before it begins.
"""

import json
import time
from dataclasses import asdict, dataclass
from typing import Any, Dict, List, Optional

from .logging import get_logger


@dataclass
class PreOptimizationSummary:
    """
    Container for pre-optimization summary information.

    This class collects and formats key information about the optimization
    process that will be displayed to users before optimization begins.
    """

    task_model: str
    proposer_model: str
    metric_name: str
    train_size: int
    val_size: int
    mipro_params: Dict[str, Any]
    guidance: Optional[str] = None
    baseline_score: Optional[float] = None

    def to_pretty(self) -> str:
        """
        Format the summary as a human-readable string.

        Returns:
            A formatted string suitable for console display
        """
        pad = " " * 4
        lines = [
            "=== Pre-Optimization Summary ===",
            f"{pad}Task Model       : {self.task_model}",
            f"{pad}Proposer Model   : {self.proposer_model}",
            f"{pad}Metric           : {self.metric_name}",
            f"{pad}Train / Val size : {self.train_size} / {self.val_size}",
            f"{pad}MIPRO Params     : {json.dumps(self.mipro_params, separators=(',', ':'))}",
        ]

        if self.guidance:
            # Truncate guidance for readability
            guidance_display = self.guidance[:120]
            if len(self.guidance) > 120:
                guidance_display += "..."
            lines.append(f"{pad}Guidance         : {guidance_display}")

        if self.baseline_score is not None:
            lines.append(f"{pad}Baseline score   : {self.baseline_score:.4f}")

        return "\n".join(lines)

    def to_json(self) -> str:
        """
        Convert the summary to JSON format.

        Returns:
            JSON string representation of the summary
        """
        return json.dumps(asdict(self), indent=2)

    def log(self) -> None:
        """
        Log the summary using the configured logger.

        This method outputs the formatted summary at INFO level.
        """
        logger = get_logger()
        logger.progress(self.to_pretty())


@dataclass
class CandidateInfo:
    """
    Information about a single instruction proposal candidate.

    This class tracks timing and content for each candidate instruction
    generated during the optimization process.
    """

    idx: int
    instructions: Optional[str] = None
    start_ts: Optional[float] = None
    end_ts: Optional[float] = None

    @property
    def duration(self) -> Optional[float]:
        """Calculate duration if both timestamps are available."""
        if self.start_ts is not None and self.end_ts is not None:
            return self.end_ts - self.start_ts
        return None


class InstructionProposalTracker:
    """
    Tracks and displays progress during the instruction proposal phase.

    This class provides real-time progress indicators and timing information
    for each candidate instruction generated by the proposer model during
    optimization.
    """

    def __init__(self, total: int, bar_length: int = 30):
        """
        Initialize the tracker.

        Args:
            total: Total number of instruction candidates to be generated
            bar_length: Length of the progress bar in characters
        """
        self.total = total
        self.bar_length = bar_length
        self.candidates: List[CandidateInfo] = []
        self.logger = get_logger()

    def start_candidate(self, idx: int) -> None:
        """
        Mark the start of generating a candidate instruction.

        Args:
            idx: Index of the candidate (1-based)
        """
        candidate = CandidateInfo(idx=idx, start_ts=time.time())
        self.candidates.append(candidate)
        # Don't display progress here to avoid duplicates

    def end_candidate(self, idx: int, instructions: str) -> None:
        """
        Mark the completion of generating a candidate instruction.

        Args:
            idx: Index of the candidate (1-based)
            instructions: The generated instruction text
        """
        if idx <= len(self.candidates):
            candidate = self.candidates[idx - 1]
            candidate.instructions = instructions
            candidate.end_ts = time.time()
            self._display_progress(idx)  # Show progress after completing this candidate

    def _display_progress(self, completed: int) -> None:
        """
        Display current progress with a progress bar.

        Args:
            completed: Number of candidates completed so far
        """
        if self.total == 0:
            return

        # Cap the display at 100% to avoid confusing output
        display_completed = min(completed, self.total)
        percentage = (display_completed / self.total) * 100
        filled_length = int(self.bar_length * display_completed / self.total)
        bar = "█" * filled_length + "░" * (self.bar_length - filled_length)

        # Calculate average time per candidate if we have completed candidates
        avg_time_str = ""
        if completed > 0:
            total_time = sum(
                c.duration
                for c in self.candidates[:completed]
                if c.duration is not None
            )
            if total_time > 0:
                avg_time = total_time / completed
                avg_time_str = f" | avg: {avg_time:.2f}s"

        # Show actual count if it exceeds expected
        count_display = f"{display_completed}/{self.total}"
        if completed > self.total:
            count_display = (
                f"{self.total}/{self.total} (+{completed - self.total} extra)"
            )

        progress_msg = (
            f"⏳ Proposing instructions: |{bar}| {count_display} "
            f"({percentage:4.1f}%){avg_time_str}"
        )

        self.logger.progress(progress_msg)

    def get_summary(self) -> Dict[str, Any]:
        """
        Get a summary of all tracked candidates.

        Returns:
            Dictionary containing summary information
        """
        completed_candidates = [c for c in self.candidates if c.end_ts is not None]
        total_time = sum(
            c.duration for c in completed_candidates if c.duration is not None
        )

        return {
            "total_candidates": self.total,
            "completed_candidates": len(completed_candidates),
            "total_time": total_time,
            "average_time_per_candidate": (
                total_time / len(completed_candidates) if completed_candidates else 0
            ),
            "candidates": [
                {
                    "idx": c.idx,
                    "duration": c.duration,
                    "instructions_length": len(c.instructions) if c.instructions else 0,
                    "instructions_preview": (
                        c.instructions[:100] + "..."
                        if c.instructions and len(c.instructions) > 100
                        else c.instructions
                    ),
                }
                for c in self.candidates
            ],
        }

    def to_json(self) -> str:
        """
        Convert the tracker summary to JSON format.

        Returns:
            JSON string representation of the tracker summary
        """
        return json.dumps(self.get_summary(), indent=2)
